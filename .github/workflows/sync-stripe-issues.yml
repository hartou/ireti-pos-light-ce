name: Sync Stripe Issue Specs

on:
  push:
    paths:
      - '.github/ISSUES/**'
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  sync:
    name: Create/Update GitHub Issues from Markdown
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Sync issues from .github/ISSUES
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const ROOT = '.github/ISSUES';

            function listFilesRecursively(dir) {
              let results = [];
              for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
                const full = path.join(dir, entry.name);
                if (entry.isDirectory()) results = results.concat(listFilesRecursively(full));
                else if (entry.isFile() && entry.name.endsWith('.md')) results.push(full);
              }
              return results;
            }

            function parseFrontmatter(md) {
              // Extract content between first pair of --- lines
              const m = md.match(/^---\n([\s\S]*?)\n---\n?/);
              if (!m) return { data: {}, body: md };
              const fmRaw = m[1];
              const body = md.slice(m[0].length);
              const data = {};
              for (const line of fmRaw.split('\n')) {
                if (!line.trim() || line.trim().startsWith('#')) continue;
                const idx = line.indexOf(':');
                if (idx === -1) continue;
                const key = line.slice(0, idx).trim();
                let val = line.slice(idx + 1).trim();
                // Normalize quotes
                if (val.startsWith('[') && val.endsWith(']')) {
                  try { data[key] = JSON.parse(val); } catch (e) { data[key] = []; }
                } else {
                  if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                    val = val.slice(1, -1);
                  }
                  data[key] = val;
                }
              }
              return { data, body };
            }

            async function ensureLabels(labels) {
              if (!labels || !labels.length) return [];
              const existing = await github.paginate(github.rest.issues.listLabelsForRepo, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
              });
              const existingNames = new Set(existing.map(l => l.name));
              for (const name of labels) {
                if (!existingNames.has(name)) {
                  try {
                    await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name });
                  } catch (e) {
                    core.warning(`Could not create label ${name}: ${e.message}`);
                  }
                }
              }
              return labels;
            }

            async function ensureMilestone(title) {
              if (!title) return undefined;
              const milestones = await github.paginate(github.rest.issues.listMilestones, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
              });
              const found = milestones.find(m => m.title === title);
              if (found) return found.number;
              try {
                const created = await github.rest.issues.createMilestone({ owner: context.repo.owner, repo: context.repo.repo, title });
                return created.data.number;
              } catch (e) {
                core.warning(`Could not create milestone ${title}: ${e.message}`);
                return undefined;
              }
            }

            async function findIssueByTitle(title) {
              // Use search API across open/closed issues
              const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue "${title.replace(/\"/g, '\\"')}" in:title`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
              const match = res.data.items.find(i => i.title === title && i.pull_request === undefined);
              return match;
            }

            const files = fs.existsSync(ROOT) ? listFilesRecursively(ROOT) : [];
            if (!files.length) {
              core.info('No issue spec files found. Skipping.');
              return;
            }

            for (const file of files) {
              const content = fs.readFileSync(file, 'utf8');
              const { data, body } = parseFrontmatter(content);
              const title = data.title || path.basename(file, '.md');
              const labels = await ensureLabels(data.labels || []);
              const milestoneNumber = await ensureMilestone(data.milestone);
              const assignees = Array.isArray(data.assignees) ? data.assignees : [];

              const footer = `\n\n---\nSource: ${file}`;
              const issueBody = `${body.trim()}${footer}`;

              const existing = await findIssueByTitle(title);
              if (existing) {
                core.info(`Updating issue #${existing.number}: ${title}`);
                try {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existing.number,
                    title,
                    body: issueBody,
                    labels,
                    milestone: milestoneNumber,
                    assignees,
                  });
                } catch (e) {
                  core.warning(`Failed to update issue ${existing.number}: ${e.message}`);
                }
              } else {
                core.info(`Creating issue: ${title}`);
                try {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title,
                    body: issueBody,
                    labels,
                    milestone: milestoneNumber,
                    assignees,
                  });
                } catch (e) {
                  core.warning(`Failed to create issue for ${file}: ${e.message}`);
                }
              }
            }